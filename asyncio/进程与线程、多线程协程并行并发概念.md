https://www.jianshu.com/p/48893a7125a1

http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html (进程线程极易理解)

https://zhuanlan.zhihu.com/p/23755202?refer=passer （常用的操作系统知识）


1，进程与线程的区别:
* 1，线程是程序执行的最小单位，是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，而进程是操作系统分配资源的最小单位 （这句话一定要理解）；
* 2，一个进程可以有多个线程，多个线程也可以并发执行；

* 3，进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程
* 4，不可见；一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
* 5，调度和切换：线程上下文切换比进程上下文切换要快得多。
* 6，进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
* 7，线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。

2，大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。

3，多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。

4，内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

5，一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。

6，现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍。

6，与并行不同，单核单线程能支持并发（特指协程）。那么，如何实现支持并发的设计？两个字：拆分。
之所以并发设计往往需要把流程拆开，是因为如果不拆分也就不可能在同一时间段进行多个任务了。这种拆分可以是平行的拆分，比如抽象成同类的任务，也可以是不平行的，比如分为多个步骤。

并发和并行的区别：
并行指物理上同时执行，并发指能够让多个任务在逻辑上交织执行的程序设计

7，虽然python有GIL锁，启用多线程的时候只能用一个cpu核心，但python线程仍然适合I/O密集型应用:标准库中每个使用 C 语言编写的 I/O 函数都会释放 GIL，因此，当某个线程在等待 I/O 时， Python 调度程序会切换到另一个线程。 （意思就是说I/O操作的延迟大于过程中程序运行时间,我完全可以在延迟的时候,切换到其他线程，做其他操作。CPython 解释器本身就不是线程安全的，因此有全局解释器锁（GIL），一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程通常不能同时使用多个 CPU 核心。这是 CPython 解释器的局限，与 Python 语言本身无关。Jython 和 IronPython 没有这种限制。不过，目前最快的 Python解释器 PyPy 也有 GIL。然而，标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着在 Python 语言这个层次上可以使用多线程，而 I/O 密集型 Python 程序能从中受益：一个 Python 线程等待网络响应时，阻塞型 I/O 函数会释放 GIL，再运行一个线程。

**总结：唯有在处理CPU密集型的时候才需要考虑GIL，I/O密集型的处理则不必**

8，多线程与协程的区别：协程执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，不像多线程那样要切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。

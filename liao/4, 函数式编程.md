## 1, 函数式编程
函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，**这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元**。

而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但**其思想更接近数学计算**。

我们首先要搞明白计算机（Computer）和计算（Compute）的概念。

在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。

而计算则指数学意义上的计算，**越是抽象的计算，离计算机硬件越远**。

**对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言**。

函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为**没有副作用**。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是**有副作用的**。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

Python对函数式编程提供部分支持。由于Python允许使用变量，因此，**Python不是纯函数式编程语言**。

## 2. 高阶函数 Higher-order function:就是让函数的参数能够接收别的函数。除了可以接受函数作为参数外，还可以把函数作为结果值返回。（这里听抽象的，但是后来发现还是很重要的）
**1，变量可以指向函数**, abs(-10)是函数调用，而abs是函数本身。要获得函数调用结果，我们可以把结果赋值给变量:x = abs(-10) = 10, 如果把函数本身赋值给变量:f = abs, f = <built-in function abs>.结论：函数本身也可以赋值给变量，即：变量可以指向函数。如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数:f = abs,f(-10)=10

**2.函数名其实就是指向函数的变量**！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！

3.既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为**高阶函数。**

### 1,map/reduce
map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
```
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```
map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```
如果要把序列[1, 3, 5, 7, 9]变换成整数13579，
```
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
```
这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出**把str转换为int的函数**：
```
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> def char2num(s):
...     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
...     return digits[s]
...
>>> reduce(fn, map(char2num, '13579'))
13579
```
整理成一个str2int的函数就是：
```
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
```
还可以用lambda函数进一步简化成：
```
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```
### 2,filter()函数用于过滤序列
filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。

例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
```
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```
把一个序列中的空字符串删掉，可以这么写：
```
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']
```
strip()用于移除字符串头尾指定的字符，只能删除开头或是结尾的字符，不能删除中间部分的字符。

http://www.runoob.com/python/att-string-strip.html
### 3,sorted():用sorted()排序的关键在于实现一个映射函数。
Python内置的sorted()函数就可以对list进行排序：
```
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
```
此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
```
>>> sorted([36, 5, -12, 9, -21], key=abs) # key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。
[5, 9, -12, -21, 36]
```
再看一个字符串排序的例子：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
```
默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。

现在，我们提出排序应该忽略大小写，按照字母序排序。只要用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。

这样，我们给sorted传入key函数，即可实现忽略大小写的排序：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
```
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```
### 4, 返回函数：高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
>* 一个函数可以返回一个计算结果，也可以返回一个函数。
>* 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。

通常情况下，求和的函数是这样定义的：
```
def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax
```
但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？**可以不返回求和的结果，而是返回求和的函数**：
```
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum  # 这里很重要
```
当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
```
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
```
调用函数f时，才真正计算求和的结果：
```
>>> f()
25
```
在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种**称为“闭包（Closure）”的程序结构**拥有极大的威力。

